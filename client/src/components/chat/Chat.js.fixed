import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  Box,
  Grid,
  Paper,
  Avatar,
  TextField,
  IconButton,
  Typography,
  Badge,
  CircularProgress,
  Tooltip,
  AppBar,
  Toolbar,
  keyframes,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Button,
  useMediaQuery,
  useTheme,
  Fab,
  Menu,
  MenuItem,
  Divider,
  Switch,
  FormControlLabel,
  FormGroup,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemSecondaryAction,
  Tab,
  Tabs
} from '@mui/material';
import { toast } from 'react-toastify';
import SendIcon from '@mui/icons-material/Send';
import RefreshIcon from '@mui/icons-material/Refresh';
import DoneIcon from '@mui/icons-material/Done';
import DoneAllIcon from '@mui/icons-material/DoneAll';
import PersonIcon from '@mui/icons-material/Person';
import ChatIcon from '@mui/icons-material/Chat';
import PersonAddIcon from '@mui/icons-material/PersonAdd';
import PhoneIcon from '@mui/icons-material/Phone';
import DeleteIcon from '@mui/icons-material/Delete';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import CallIcon from '@mui/icons-material/Call';
import VideocamIcon from '@mui/icons-material/Videocam';
import { useAuth } from '../../contexts/AuthContext';
import { useSocket } from '../../contexts/SocketContext';
import axios from 'axios';
import { format } from 'timeago.js';
import AddChatByPhone from './AddChatByPhone';
import { setAuthToken } from '../../contexts/AuthContext';
import ProfileMenu from '../profile/ProfileMenu';
import CallModal from '../call/CallModal';
import IncomingCallAlert from '../call/IncomingCallAlert';
import NotificationsIcon from '@mui/icons-material/Notifications';

// Modified API base URL with port detection
const API_BASE_URL = (() => {
  // Use localhost in development for reliable connection
  const host = process.env.REACT_APP_API_HOST || 'localhost';
  // Use the port from .env or default to 5000
  const port = process.env.REACT_APP_API_PORT || '5000';
  return `http://${host}:${port}`;
})();

// Configure axios with common settings
axios.defaults.baseURL = API_BASE_URL;
axios.defaults.timeout = 10000;
axios.defaults.headers.post['Content-Type'] = 'application/json';

// Define the flashing animation
const flash = keyframes`
  0%, 100% {
    background-color: #2196f3;
    color: white;
  }
  50% {
    background-color: #64b5f6;
    color: white;
  }
`;

// Define the playNotificationSound function before any useEffect hooks that reference it
const playNotificationSound = () => {
  try {
    const audio = new Audio('/notification.mp3');
    audio.volume = 0.5; // Set volume to 50%
    
    const playPromise = audio.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.warn('Audio playback prevented by browser:', error);
      });
    }
  } catch (error) {
    console.error('Failed to play notification sound:', error);
  }
};

// Define a helper function to get the correct image URL
const getImageUrl = (url) => {
  if (!url) return '';
  
  // If it's already a full URL, return it as is
  if (url.startsWith('http')) {
    console.log('Using absolute image URL:', url);
    return url;
  }
  
  // Make sure the URL starts with a slash if it doesn't already
  const formattedUrl = url.startsWith('/') ? url : `/${url}`;
  const fullUrl = `${API_BASE_URL}${formattedUrl}`;
  
  console.log('Formatted image URL:', fullUrl);
  return fullUrl;
};

// Add this near the top of the file after other imports, before the Chat component definition
const pulseAnimation = keyframes`
  0% {
    transform: scale(0.95);
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
  }
  70% {
    transform: scale(1);
    box-shadow: 0 0 0 5px rgba(76, 175, 80, 0);
  }
  100% {
    transform: scale(0.95);
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
  }
`;

const Chat = () => {
  const [users, setUsers] = useState([]);
  const [chats, setChats] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [selectedChat, setSelectedChat] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  // eslint-disable-next-line no-unused-vars
  const [apiError, setApiError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [connectionStatus, setConnectionStatus] = useState('connecting');
  const messagesEndRef = useRef(null);
  const typingTimeoutRef = useRef(null);
  // eslint-disable-next-line no-unused-vars
  const { user, logout, recentlyLoggedIn, refreshToken } = useAuth();
  const { socket, connected, connectionError, emitEvent, joinRoom, leaveRoom } = useSocket();
  const [isTyping, setIsTyping] = useState(false);
  // eslint-disable-next-line no-unused-vars
  const [typingUsers, setTypingUsers] = useState({});
  // eslint-disable-next-line no-unused-vars
  const [activeTab, setActiveTab] = useState(0);
  // eslint-disable-next-line no-unused-vars
  const [onlineUsers, setOnlineUsers] = useState([]);
  const [openAddByPhone, setOpenAddByPhone] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [chatToDelete, setChatToDelete] = useState(null);
  const [profileMenuOpen, setProfileMenuOpen] = useState(false);
  const [notificationSettings, setNotificationSettings] = useState({
    messageNotifications: true,
    callNotifications: true,
    contactStatusNotifications: false,
    messageReadNotifications: false,
    sound: true
  });
  const [notificationSettingsOpen, setNotificationSettingsOpen] = useState(false);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const [mobileView, setMobileView] = useState('list'); // 'list' or 'chat'
  const [callModalOpen, setCallModalOpen] = useState(false);
  const [incomingCallOpen, setIncomingCallOpen] = useState(false);
  const [currentCall, setCurrentCall] = useState(null);
  const [incomingCallData, setIncomingCallData] = useState(null);
  const [ringtoneAudio, setRingtoneAudio] = useState(null);
  const [profileAnchorEl, setProfileAnchorEl] = useState(null);

  // Define showNotification function inside the component where it can access notificationSettings
  const showNotification = (title, body, icon = null, type = 'message') => {
    // Check if the browser supports notifications
    if (!("Notification" in window)) {
      console.log("This browser does not support desktop notifications");
      return;
    }

    // Check if the user is actively using the app
    const isDocumentVisible = !document.hidden;
    
    // Check notification settings
    const shouldShowNotification = 
      (type === 'message' && notificationSettings.messageNotifications) ||
      (type === 'call' && notificationSettings.callNotifications) ||
      (type === 'status' && notificationSettings.contactStatusNotifications) ||
      (type === 'read' && notificationSettings.messageReadNotifications);
    
    // Only show notifications if permission is granted, document is not visible, and settings allow
    if (Notification.permission === "granted" && !isDocumentVisible && shouldShowNotification) {
      try {
        const notification = new Notification(title, {
          body: body,
          icon: icon || '/logo192.png', // Default app icon
          tag: 'chat-notification', // Tag to replace previous notifications
          silent: !notificationSettings.sound // Allow sound based on settings
        });
        
        // Close notification after 5 seconds
        setTimeout(() => notification.close(), 5000);
        
        // Handle notification click
        notification.onclick = function() {
          window.focus(); // Focus the window
          this.close();
        };
        
        // Play sound if enabled
        if (notificationSettings.sound) {
          playNotificationSound();
        }
      } catch (error) {
        console.error('Error showing notification:', error);
      }
    } else if (Notification.permission !== "denied" && !isDocumentVisible && shouldShowNotification) {
      // Request permission if not already granted or denied
      Notification.requestPermission().then(permission => {
        if (permission === "granted") {
          showNotification(title, body, icon, type);
        }
      });
    }
  };

  // Scroll to bottom more reliably - Define this function early before it's used in other functions
  const scrollToBottom = useCallback(() => {
    if (messagesEndRef.current) {
      // Force scroll to end with "auto" behavior for immediate scrolling
      messagesEndRef.current.scrollIntoView({ 
        behavior: "auto", 
        block: "end"
      });
      console.log('Scrolled to bottom of messages');
    } else {
      console.warn('Messages end ref not available');
    }
  }, [messagesEndRef]);

  // Set auth token on component mount
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      setAuthToken(token);
    }
  }, []);

  // Request notification permission
  useEffect(() => {
    // Check if the browser supports notifications
    if ('Notification' in window) {
      // If permission is not granted or denied
      if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
        // Request permission
        Notification.requestPermission().then(permission => {
          console.log('Notification permission:', permission);
        });
      } else {
        console.log('Notification permission status:', Notification.permission);
      }
    } else {
      console.log('This browser does not support desktop notifications');
    }
  }, []);

  // Initial server connection check
  useEffect(() => {
    // Ping server to check if it's available
    const checkServerConnection = async () => {
      try {
        setConnectionStatus('connecting');
        await axios.get(`${API_BASE_URL}`);
        setConnectionStatus('connected');
        setApiError(null);
      } catch (error) {
        console.error('Server connection check failed:', error);
        setConnectionStatus('disconnected');
        setApiError('Cannot connect to server. Please check your connection or try again later.');
      }
    };

    checkServerConnection();
  }, []);

  // Update connection status based on socket connection
  useEffect(() => {
    if (connected) {
      setConnectionStatus('connected');
      setApiError(null);
    } else if (connectionError) {
      setConnectionStatus('disconnected');
      setApiError(connectionError);
    }
  }, [connected, connectionError]);

  // Define fetchUsers and fetchChats before they're used in useEffects
  const fetchUsers = useCallback(async () => {
    try {
      setLoading(true);
      setApiError(null);
      
      const response = await axios.get(`${API_BASE_URL}/api/users`);
      
      if (response && response.data) {
        setUsers(response.data);
        // Filter online users (excluding current user)
        setOnlineUsers(response.data.filter(u => u.isOnline && u._id !== user.id));
      } else {
        setUsers([]);
        setOnlineUsers([]);
        console.warn('No user data received');
      }
    } catch (error) {
      console.error('Error fetching users:', error);
      if (error.message === 'Network Error') {
        setApiError('Network error: Cannot connect to server. Please check your connection.');
        setConnectionStatus('disconnected');
      } else {
        setApiError('Failed to load users. Please try again later.');
      }
      setUsers([]);
      setOnlineUsers([]);
    } finally {
      setLoading(false);
    }
  }, [user, setUsers, setOnlineUsers, setLoading, setApiError, setConnectionStatus]);

  const fetchChats = useCallback(async () => {
    try {
      setLoading(true);
      setApiError(null);
      
      const response = await axios.get(`${API_BASE_URL}/api/chats`);
      
      if (response && response.data) {
        setChats(response.data);
      } else {
        setChats([]);
        console.warn('No chat data received');
      }
    } catch (error) {
      console.error('Error fetching chats:', error);
      if (error.message === 'Network Error') {
        setApiError('Network error: Cannot connect to server. Please check your connection.');
        setConnectionStatus('disconnected');
      } else {
        setApiError('Failed to load chats. Please try again later.');
      }
      setChats([]);
    } finally {
      setLoading(false);
    }
  }, [setChats, setLoading, setApiError, setConnectionStatus]);

  const fetchMessages = useCallback(async (userId) => {
    try {
      setLoading(true);
      setApiError(null);
      
      console.log(`Fetching messages for user ${userId}`);
      const response = await axios.get(`${API_BASE_URL}/api/messages/${userId}`);
      
      if (response && response.data) {
        // Sort messages to ensure newest messages are at the bottom
        const sortedMessages = [...response.data].sort((a, b) => 
          new Date(a.createdAt) - new Date(b.createdAt)
        );
        
        console.log(`Received ${sortedMessages.length} messages`);
        
        // Set messages and force an immediate scroll to the bottom
        setMessages(sortedMessages);
        
        // Force an immediate scroll to the bottom
        requestAnimationFrame(() => {
          scrollToBottom();
          // Double-check with a small delay to ensure DOM is fully updated
          setTimeout(() => {
            scrollToBottom();
          }, 50);
        });
      }
    } catch (error) {
      console.error('Error fetching messages:', error);
      if (error.message === 'Network Error') {
        setConnectionStatus('disconnected');
        setApiError('Network error: Cannot connect to server');
      } else {
        setApiError('Failed to load messages. Please try again.');
      }
    } finally {
      setLoading(false);
    }
  }, [scrollToBottom]);

  // Handle socket events for real-time updates
  useEffect(() => {
    if (socket && connected) {
      console.log("Setting up socket event listeners");
      
      // Handle incoming messages
      const handleReceiveMessage = (messageData) => {
        console.log("Received message via socket:", messageData);
        
        // Only add the message if it doesn't already exist
        if (!messages.some(m => m._id === messageData._id)) {
          // Add the message to our state
          setMessages(prevMessages => [...prevMessages, messageData]);
          scrollToBottom();
          
          // Play notification sound for new messages if not from current user
          // and not focused on this chat
          if (messageData.sender !== user.id && 
             (messageData.chatId !== selectedChat?._id || document.hidden)) {
            playNotificationSound();
            
            // Find sender details to use in notification
            const sender = users.find(u => u._id === messageData.sender);
            const senderName = sender?.name || 'Someone';
            const senderIcon = sender?.profilePicture ? getImageUrl(sender.profilePicture) : null;
            
            // Show notification
            showNotification(
              `${senderName}`, 
              messageData.content.length > 50 ? `${messageData.content.substring(0, 50)}...` : messageData.content,
              senderIcon,
              'message'
            );
          }
        }
      };
      
      // Handle chat refresh signal
      const handleChatRefresh = (data) => {
        console.log("Chat refresh signal received:", data);
        
        if (data && data.chatId) {
          // Update the chat list with the latest message info
          setChats(prevChats => 
            prevChats.map(chat => {
              if (chat._id === data.chatId) {
                return {
                  ...chat,
                  lastMessage: {
                    content: data.lastMessage.content,
                    createdAt: data.lastMessage.timestamp,
                    type: data.lastMessage.type || 'text'
                  },
                  updatedAt: data.lastMessage.timestamp
                };
              }
              return chat;
            })
          );
          
          // Re-sort chats to ensure latest message is at the top
          setChats(prevChats => 
            [...prevChats].sort((a, b) => {
              const aTime = a.lastMessage?.createdAt || a.updatedAt || new Date(0).toISOString();
              const bTime = b.lastMessage?.createdAt || b.updatedAt || new Date(0).toISOString();
              return new Date(bTime) - new Date(aTime);
            })
          );
        }
      };
      
      // Handle updated chat list
      const handleChatListUpdated = (data) => {
        console.log("Chat list update received:", data);
        
        if (data && data.chats) {
          setChats(data.chats);
        }
      };
      
      // Handle message delivered confirmation
      const handleMessageDelivered = (status) => {
        console.log("Message delivery status received:", status);
        
        if (status && status.tempId) {
          setMessages(prevMessages => 
            prevMessages.map(msg => 
              msg.tempId === status.tempId ? 
                { 
                  ...msg, 
                  status: status.status,
                  _id: status.messageId || msg._id,
                  createdAt: status.timestamp || msg.createdAt,
                  isSent: true 
                } : msg
            )
          );
          
          // Also refresh chat list to show updated last message
          fetchChats();
        }
      };
      
      // Handle message read status update
      const handleMessageStatus = (status) => {
        console.log('Message status update:', status);
        
        if (status && status.messageId) {
          // Update the status of the specific message
          setMessages(prevMessages => 
            prevMessages.map(msg => 
              msg._id === status.messageId || msg.tempId === status.messageId
                ? { ...msg, status: status.status, read: status.status === 'read', readAt: status.status === 'read' ? new Date().toISOString() : msg.readAt }
                : msg
            )
          );
          
          // Show notification when message is read
          if (status.status === 'read' && !document.hasFocus()) {
            const recipient = users.find(u => u._id === status.readerId);
            if (recipient) {
              showNotification(
                'Message Read',
                `${recipient.name} has read your message`,
                recipient.profilePicture ? getImageUrl(recipient.profilePicture) : null,
                'read'
              );
            }
          }
        }
      };
      
      // Handle typing status updates
      const handleTypingStatus = (data) => {
        console.log("Typing status update:", data);
        
        if (data && data.chatId) {
          // Update the typing users for this chat
          setTypingUsers(prev => ({
            ...prev,
            [data.chatId]: data.users || []
          }));
        }
      };
      
      // Handle user online status updates
      const handleUserStatus = (data) => {
        if (data && data.userId) {
          console.log('User status update:', data);
          
          // Update users with online status
          setUsers(prevUsers => 
            prevUsers.map(user => 
              user._id === data.userId 
                ? { ...user, isOnline: data.isOnline } 
                : user
            )
          );
          
          // Update online users list
          if (data.isOnline) {
            setOnlineUsers(prev => {
              // Only add if not already in list
              if (!prev.some(u => u._id === data.userId) && data.userId !== user.id) {
                // Find the user details
                const userDetails = users.find(u => u._id === data.userId);
                if (userDetails) {
                  // Show notification for important contacts
                  const isChatPartner = chats.some(chat => 
                    chat.user && chat.user._id === data.userId);
                    
                  if (isChatPartner) {
                    showNotification(
                      'Contact Online',
                      `${userDetails.name} is now online`,
                      userDetails.profilePicture ? getImageUrl(userDetails.profilePicture) : null,
                      'status'
                    );
                  }
                  return [...prev, userDetails];
                }
              }
              return prev;
            });
          } else {
            setOnlineUsers(prev => {
              // Find the user that went offline
              const userGoingOffline = prev.find(u => u._id === data.userId);
              
              // Filter out the user who went offline
              const newList = prev.filter(u => u._id !== data.userId);
              
              // Notify about important contacts going offline
              if (userGoingOffline) {
                const isChatPartner = chats.some(chat => 
                  chat.user && chat.user._id === data.userId);
                
                if (isChatPartner) {
                  showNotification(
                    'Contact Offline',
                    `${userGoingOffline.name} has gone offline`,
                    userGoingOffline.profilePicture ? getImageUrl(userGoingOffline.profilePicture) : null,
                    'status'
                  );
                }
              }
              
              return newList;
            });
          }
        }
      };
      
      // Register event listeners
      socket.on('receive_message', handleReceiveMessage);
      socket.on('message_delivered', handleMessageDelivered);
      socket.on('message_status', handleMessageStatus);
      socket.on('typing_status', handleTypingStatus);
      socket.on('user_status', handleUserStatus);
      socket.on('chat_refresh', handleChatRefresh);
      socket.on('chat_list_updated', handleChatListUpdated);
      socket.on('message_error', (error) => console.error("Socket message error:", error));
      
      // Request a chat list refresh when initially connecting
      if (user && user.id) {
        emitEvent('request_chat_refresh', user.id);
      }
      
      // Cleanup function to remove listeners
      return () => {
        socket.off('receive_message', handleReceiveMessage);
        socket.off('message_delivered', handleMessageDelivered);
        socket.off('message_status', handleMessageStatus);
        socket.off('typing_status', handleTypingStatus);
        socket.off('user_status', handleUserStatus);
        socket.off('chat_refresh', handleChatRefresh);
        socket.off('chat_list_updated', handleChatListUpdated);
        socket.off('message_error');
      };
    }
  }, [socket, connected, messages, selectedChat, selectedUser, user, emitEvent, scrollToBottom, playNotificationSound, setChats, fetchChats]);

  // Fetch initial data
  useEffect(() => {
    if (user && connectionStatus === 'connected') {
      fetchUsers();
      fetchChats();
    }
  }, [user, connectionStatus, fetchUsers, fetchChats]);

  // Fetch messages when user is selected
  useEffect(() => {
    if (selectedUser && connectionStatus === 'connected') {
      fetchMessages(selectedUser._id);
    }
  }, [selectedUser, connectionStatus, fetchMessages]);

  // Join/leave chat room when chat changes
  useEffect(() => {
    if (socket && connected && selectedChat && selectedChat._id) {
      console.log('Joining chat room:', selectedChat._id);
      joinRoom(selectedChat._id);
      
      // Mark all unread messages as read
      if (selectedChat.unreadCount && selectedChat.unreadCount > 0) {
        const unreadMessages = messages.filter(msg => 
          msg.sender !== user.id && !msg.read
        );
        
        // Send read receipts for unread messages
        unreadMessages.forEach(msg => {
          emitEvent('message_read', {
            messageId: msg._id,
            chatId: selectedChat._id,
            readerId: user.id
          });
        });
      }
      
      return () => {
        // Leave the chat room when component unmounts or chat changes
        if (selectedChat._id) {
          leaveRoom(selectedChat._id);
        }
      };
    }
  }, [socket, connected, selectedChat, user, joinRoom, leaveRoom, emitEvent, messages]);

  // Auto-scroll when messages change with better performance
  useEffect(() => {
    if (messages.length > 0) {
      // Use requestAnimationFrame for smoother scrolling
      requestAnimationFrame(() => {
        scrollToBottom();
        
        // And another scroll after a short delay to ensure rendering is complete
        const timeoutId = setTimeout(() => {
          scrollToBottom();
        }, 100);
        
        return () => clearTimeout(timeoutId);
      });
    }
  }, [messages, scrollToBottom]);

  // Add new useEffect to monitor for chat updates and refresh the list
  useEffect(() => {
    let chatRefreshInterval;
    
    if (socket && connected) {
      // Set up a heartbeat to check for new messages
      chatRefreshInterval = setInterval(() => {
        if (selectedChat) {
          // Only fetch messages if a chat is selected to avoid unnecessary requests
          fetchMessages(selectedUser?._id);
        }
        // Always refresh the chats list for latest updates
        fetchChats();
      }, 30000); // Every 30 seconds as a fallback
    }
    
    return () => {
      if (chatRefreshInterval) {
        clearInterval(chatRefreshInterval);
      }
    };
  }, [socket, connected, selectedChat, selectedUser, fetchChats, fetchMessages]);

  // Handle call-related socket events
  useEffect(() => {
    if (socket && connected && user) {
      // Handler for incoming calls
      const handleIncomingCall = (data) => {
        console.log('Incoming call from:', data.from, data);
        
        // Create caller object
        const caller = {
          _id: data.from,
          name: data.callerName,
          profilePicture: data.callerPicture,
        };
        
        // Update state for incoming call
        setIncomingCallData({
          caller,
          callType: data.callType
        });
        
        // Show the incoming call alert
        setIncomingCallOpen(true);
        
        // Play ringtone
        if (!ringtoneAudio) {
          const audio = new Audio('/sounds/ringtone.mp3');
          audio.loop = true;
          audio.play().catch(err => console.error('Failed to play ringtone:', err));
          setRingtoneAudio(audio);
        }
        
        // Show notification for incoming call
        showNotification(
          'Incoming Call',
          `${data.callerName || 'Someone'} is calling you`,
          data.callerPicture ? getImageUrl(data.callerPicture) : null,
          'call'
        );
      };
      
      // Handler for call rejection
      const handleCallRejected = (data) => {
        console.log('Call rejected by:', data.from);
        
        // Stop ringtone if playing
        if (ringtoneAudio) {
          ringtoneAudio.pause();
          ringtoneAudio.currentTime = 0;
          setRingtoneAudio(null);
        }
        
        // Close modal if open
        setCallModalOpen(false);
        setCurrentCall(null);
        
        // Show notification
        toast.info(`${data.from === selectedChat?.user?.name ? selectedChat?.user?.name : 'User'} rejected the call`);
      };
      
      // Handler for call ended
      const handleCallEnded = (data) => {
        console.log('Call ended by:', data.from);
        
        // Stop ringtone if playing
        if (ringtoneAudio) {
          ringtoneAudio.pause();
          ringtoneAudio.currentTime = 0;
          setRingtoneAudio(null);
        }
        
        // Cleanup media stream
        if (window.localStream) {
          console.log('Cleaning up local stream after call ended');
          window.localStream.getTracks().forEach(track => track.stop());
          window.localStream = null;
        }
        
        // Close modals
        setCallModalOpen(false);
        setIncomingCallOpen(false);
        setCurrentCall(null);
        setIncomingCallData(null);
        
        // Show notification
        toast.info('Call ended');
      };
      
      // Register socket event listeners for call-related events
      socket.on('incoming_call', handleIncomingCall);
      socket.on('call_rejected', handleCallRejected);
      socket.on('call_ended', handleCallEnded);
      
      // Cleanup function
      return () => {
        // Remove socket event listeners
        socket.off('incoming_call', handleIncomingCall);
        socket.off('call_rejected', handleCallRejected);
        socket.off('call_ended', handleCallEnded);
        
        // Stop ringtone if playing
        if (ringtoneAudio) {
          ringtoneAudio.pause();
          ringtoneAudio.currentTime = 0;
        }
        
        // Cleanup media stream
        if (window.localStream) {
          window.localStream.getTracks().forEach(track => track.stop());
          window.localStream = null;
        }
      };
    }
  }, [socket, connected, user, selectedChat, ringtoneAudio]);
  
  // Update the function to handle accepting calls 
  const callAcceptHandler = (video = false) => {
    // Hide incoming call alert
    setIncomingCallOpen(false);
    
    // Stop ringtone
    if (ringtoneAudio) {
      ringtoneAudio.pause();
      ringtoneAudio.currentTime = 0;
      setRingtoneAudio(null);
    }
    
    if (!incomingCallData || !incomingCallData.caller) {
      console.error('Missing caller information');
      return;
    }
    
    // Emit call accepted event
    emitEvent('call_accepted', {
      to: incomingCallData.caller._id,
      from: user.id
    });
    
    // Show call modal
    setCurrentCall({
      caller: incomingCallData.caller,
      callType: video ? 'video' : incomingCallData.callType || 'audio'
    });
    
    setCallModalOpen(true);
  };
  
  // Update the function to handle rejecting calls
  const callRejectHandler = () => {
    console.log('Rejecting incoming call');
    
    // Stop ringtone if playing
    if (ringtoneAudio) {
      ringtoneAudio.pause();
      ringtoneAudio.currentTime = 0;
      setRingtoneAudio(null);
    }
    
    // Emit call rejected event
    if (incomingCallData && incomingCallData.caller) {
      emitEvent('call_rejected', {
        to: incomingCallData.caller._id,
        from: user.id
      });
    }
    
    // Cleanup media stream if exists
    if (window.localStream) {
      console.log('Cleaning up local stream after call rejection');
      window.localStream.getTracks().forEach(track => {
        console.log(`Stopping ${track.kind} track`);
        track.stop();
      });
      window.localStream = null;
    }
    
    // Close the incoming call alert
    setIncomingCallOpen(false);
    setIncomingCallData(null);
  };
  
  // Update the function to handle initiating calls
  const handleCall = (callType = 'audio') => {
    if (!selectedChat) return;
    
    // Set up call data
    setCurrentCall({
      remoteUser: selectedChat.user,
      isIncoming: false,
      callType
    });
    
    // Show call modal
    setCallModalOpen(true);
    
    // Emit call initiation event
    emitEvent('initiate_call', {
      to: selectedChat.user._id,
      from: user.id,
      callerName: user.name,
      callerPicture: user.profilePicture,
      callType
    });
  };

  // Handle iOS keyboard appearance pushing content up
  useEffect(() => {
    if (isMobile) {
      // Function to handle when the virtual keyboard appears
      const handleResize = () => {
        // Small timeout to ensure the keyboard is fully shown
        setTimeout(() => {
          // Force scroll to the latest message
          scrollToBottom();
        }, 300);
      };

      window.addEventListener('resize', handleResize);
      return () => {
        window.removeEventListener('resize', handleResize);
      };
    }
  }, [isMobile, scrollToBottom]);

  const retryConnection = () => {
    setApiError(null);
    window.location.reload();
  };

  // Handle sending a new message
  const handleSendMessage = async (event) => {
    if (event && event.preventDefault) {
      event.preventDefault();
    }
    
    // Trim the message to remove whitespace
    const trimmedMessage = newMessage.trim();
    console.log("Attempting to send message:", {
      trimmedMessage,
      selectedUser: selectedUser?.name,
      connected,
      selectedRecipientId: selectedUser?._id
    });
    
    // First check if we can actually send a message
    if (!trimmedMessage) {
      console.log("Message is empty, not sending");
      return;
    }
    
    if (!selectedUser || !selectedUser._id) {
      console.log("No recipient selected, cannot send message");
      return;
    }
    
    if (!selectedChat) {
      console.log("No active chat selected");
    }

    // Make sure we have a valid token
    const token = localStorage.getItem('token');
    if (!token) {
      setApiError("Authentication token missing. Please login again.");
      console.error("No auth token found for message sending");
      return;
    }
    
    // Generate a temporary ID for this message
    const tempId = `temp-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    
    // Create a temporary message to display immediately
    const tempMessage = {
      _id: tempId,
      sender: user.id,
      recipient: selectedUser._id,
      content: trimmedMessage,
      read: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      status: 'sending',
      tempId,
      isSent: false
    };
    
    // Add to messages immediately for instant UI feedback
    setMessages(prevMessages => [...prevMessages, tempMessage]);
    
    // Clear the input field and reset typing state
    setNewMessage('');
    setIsTyping(false);
    
    // Scroll to bottom to show new message immediately
    requestAnimationFrame(() => {
      scrollToBottom();
    });

      try {
      // Try to send via socket first for real-time delivery
      if (socket && connected) {
        // Prepare message data for socket
        const messageData = {
          tempId,
          senderId: user.id,
          recipientId: selectedUser._id,
          content: trimmedMessage,
          chatId: selectedChat?._id,
          timestamp: new Date().toISOString(),
          type: 'text'
        };
        
        console.log("Emitting message via socket:", messageData);
        
        // Emit the message event
        emitEvent('send_message', messageData);
      }
      
      // Ensure auth token is set in headers
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      
      // Regardless of socket connection, also send via API to ensure storage
      console.log("Sending message via API to:", `${API_BASE_URL}/api/messages`);
      console.log("Message data:", {
        recipient: selectedUser._id,
        content: trimmedMessage,
        chatId: selectedChat?._id
      });
      
      const response = await axios.post(`${API_BASE_URL}/api/messages`, {
        recipient: selectedUser._id,
        content: trimmedMessage,
        chatId: selectedChat?._id
      }, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (response.data) {
        console.log("API response for message:", response.data);
        
        // Replace the temporary message with the real one from the server
        setMessages(prevMessages => 
          prevMessages.map(msg => 
            msg._id === tempId || msg.tempId === tempId 
              ? {...response.data, status: 'sent', isSent: true} 
              : msg
          )
        );
        
        // If the message created a new chat, update selectedChat
        if (response.data.chatId && (!selectedChat || !selectedChat._id)) {
          console.log("New chat created:", response.data.chatId);
          // Fetch the chat details to update UI
          fetchChats();
        }
        
        // Update chats list to show the latest message
        fetchChats();
        
        // Clear any previous errors
        setApiError(null);
      } else {
        // Mark the message as failed if no data returned
        console.error("No data returned from server for message");
        setMessages(prevMessages => 
          prevMessages.map(msg => 
            msg._id === tempId || msg.tempId === tempId
              ? {...msg, status: 'failed'} 
              : msg
          )
        );
        setApiError("Failed to send message: Server returned empty response");
      }
    } catch (error) {
      console.error("Error sending message:", error);
      console.error("Error details:", error.response?.data);
      
      // Mark the message as failed
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg._id === tempId || msg.tempId === tempId
            ? {...msg, status: 'failed'} 
            : msg
        )
      );
      
      // Show detailed error in UI
      if (error.message === 'Network Error') {
        setConnectionStatus('disconnected');
        setApiError('Network error: Cannot connect to server. Please check your connection.');
      } else if (error.response?.status === 401) {
        setApiError('Authentication failed. Please login again.');
        // Try to refresh token
        refreshToken().catch(() => {
          logout(); // Force logout if token refresh fails
        });
      } else {
        setApiError(error.response?.data?.msg || "Failed to send message. Please try again.");
      }
    }
  };

  /* eslint-disable no-unused-vars */
  const handleChatSelect = (chat, user) => {
    setSelectedChat(chat);
    setSelectedUser(user);
    
    // Request most recent messages for this chat
    if (socket && connected && chat._id) {
      // Join the chat room
      joinRoom(chat._id);
      
      // Request latest messages
      fetchMessages(user._id);
      
      // Mark all unread messages as read
      if (chat.unreadCount && chat.unreadCount > 0) {
        // Update chat unread count in our state
        setChats(prevChats => 
          prevChats.map(c => 
            c._id === chat._id ? { ...c, unreadCount: 0 } : c
          )
        );
      }
    }
    
    if (isMobile) {
      setMobileView('chat');
    }
  };

  const getLastMessagePreview = (chat) => {
    if (!chat || !chat.lastMessage) return "No messages yet";
    
    const lastMessage = chat.lastMessage;
    if (lastMessage.type === 'text') {
      return lastMessage.content.length > 25 
        ? lastMessage.content.substring(0, 25) + '...' 
        : lastMessage.content;
    } else if (lastMessage.type === 'image') {
      return "📷 Image";
    } else if (lastMessage.type === 'file') {
      return "📎 File";
    }
    return "New message";
  };

  const handleTyping = (event) => {
    // Check if event is defined before trying to access event.target
    const value = event && event.target ? event.target.value : newMessage;
    setNewMessage(value);
    
    // Only send typing events if we have a socket connection and selected user
    if (socket && connected && selectedUser && selectedUser._id && selectedChat) {
      // If not already typing and message is not empty, emit typing start
      if (!isTyping && value.trim() !== '') {
        setIsTyping(true);
        emitEvent('typing', {
          chatId: selectedChat._id,
          userId: user.id,
          isTyping: true
        });
      } 
      // If was typing but message is now empty, emit typing stop
      else if (isTyping && value.trim() === '') {
        setIsTyping(false);
        emitEvent('typing', {
          chatId: selectedChat._id,
          userId: user.id,
          isTyping: false
        });
      }
    }
    
    // Add debounce for typing stop (user has stopped typing for 1.5 seconds)
    clearTimeout(typingTimeoutRef.current);
    typingTimeoutRef.current = setTimeout(() => {
      if (isTyping && selectedChat) {
        setIsTyping(false);
        emitEvent('typing', {
          chatId: selectedChat._id,
          userId: user.id,
          isTyping: false
        });
      }
    }, 1500);
  };

  const renderMessageStatus = (message) => {
    if (!message.sender || message.sender._id !== user.id) return null;
    
    if (message.status === 'read') {
      return <DoneAllIcon fontSize="small" color="primary" sx={{ ml: 1, fontSize: '0.8rem' }} />;
    } else if (message.status === 'delivered') {
      return <DoneAllIcon fontSize="small" sx={{ ml: 1, fontSize: '0.8rem', color: 'grey.500' }} />;
    } else if (message.status === 'sending') {
      return (
        <CircularProgress 
          size={8} 
          thickness={8} 
          sx={{ ml: 1 }} 
        />
      );
    } else if (message.status === 'failed') {
      return (
        <Tooltip title="Failed to send. Click to retry.">
          <IconButton 
            size="small" 
            color="error" 
            sx={{ ml: 1, p: 0 }}
            onClick={(e) => {
              e.stopPropagation();
              handleResendMessage(message);
            }}
          >
            <RefreshIcon fontSize="small" sx={{ fontSize: '0.8rem' }} />
          </IconButton>
        </Tooltip>
      );
    } else {
      return <DoneIcon fontSize="small" sx={{ ml: 1, fontSize: '0.8rem', color: 'grey.500' }} />;
    }
  };

  const handleResendMessage = (failedMessage) => {
    // Make sure we have a valid token
    const token = localStorage.getItem('token');
    if (!token) {
      setApiError("Authentication token missing. Please login again.");
      console.error("No auth token found for message resending");
      return;
    }
    
    // Remove the failed message
    setMessages(prev => prev.filter(msg => msg._id !== failedMessage._id));
    
    // Get the content from the failed message
    const messageContent = failedMessage.content;
    
    // Create a new temporary message with a unique ID
    const tempId = `temp-${Date.now()}`;
    const messageId = `msg-${Date.now()}`;
    
    const tempMessage = {
      _id: tempId,
      messageId: messageId,
      sender: user,
      recipient: selectedUser,
      content: messageContent,
      createdAt: new Date().toISOString(),
      status: 'sending',
      isTemp: true
    };
    
    // Add the temp message to the messages list
    setMessages(prev => [...prev, tempMessage]);
    
    // Scroll to bottom
    scrollToBottom();
    
    // Emit the socket event for real-time update
    emitEvent('send_message', {
      recipientId: selectedUser._id,
      content: messageContent,
      chatId: selectedChat?._id,
      tempId: tempId,
      messageId: messageId,
      sender: {
        _id: user.id,
        name: user.name
      }
    });
    
    // Ensure the token is set in axios headers
    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    
    console.log("Resending message via API", {
      recipientId: selectedUser._id,
      content: messageContent,
      messageId: messageId,
      token: token ? 'Present' : 'Missing'
    });
    
    // Make the API call to resend
    axios.post(`${API_BASE_URL}/api/messages`, {
      recipient: selectedUser._id,
      content: messageContent,
      messageId: messageId
    }, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      if (response && response.data) {
        console.log("Resent message API response:", response.data);
        
        // Check if this message already exists in the messages list
        const messageExists = messages.some(msg => 
          (msg.messageId === messageId && msg._id !== tempId) || 
          (response.data._id && msg._id === response.data._id)
        );
        
        if (messageExists) {
          console.log('Resent message already exists in the state, skipping update');
        } else {
          // Replace the temp message with the real one
          setMessages(prev => prev.map(msg => 
            msg._id === tempId ? {...response.data, messageId} : msg
          ));
        }
        
        // Update the chat list to show the latest message
        fetchChats();
        
        // Clear any previous errors
        setApiError(null);
      } else {
        // Handle error
        console.error("No data returned for resent message");
        setMessages(prev => prev.map(msg => 
          msg._id === tempId ? { ...msg, status: 'failed' } : msg
        ));
        setApiError("Failed to resend message: No response data");
      }
    })
    .catch(error => {
      console.error('Error resending message:', error);
      console.error('Error details:', error.response?.data);
      
      // Mark as failed
      setMessages(prev => prev.map(msg => 
        msg._id === tempId ? { ...msg, status: 'failed' } : msg
      ));
      
      if (error.message === 'Network Error') {
        setApiError('Network error: Cannot connect to server. Please check your connection.');
        setConnectionStatus('disconnected');
      } else if (error.response?.status === 401) {
        setApiError('Authentication failed. Please login again.');
        // Try to refresh token
        refreshToken().catch(() => {
          logout(); // Force logout if token refresh fails
        });
      } else {
        setApiError(error.response?.data?.msg || 'Failed to send message. Please try again.');
      }
    });
  };

  const handleUserSelect = useCallback((selectedUserData) => {
    setSelectedUser(selectedUserData);
    
    // Find if there's an existing chat with this user
    const existingChat = chats.find(chat => {
      if (chat.isGroup) return false;
      return chat.participants.some(p => p._id === selectedUserData._id);
    });
    
    if (existingChat) {
      setSelectedChat(existingChat);
    } else {
      setSelectedChat(null);
    }
    
    setActiveTab(0); // Switch back to Chats tab
  }, [chats]);

  const createNewChat = useCallback(async (selectedUserData) => {
    try {
      setLoading(true);
      setApiError(null);
      
      // Create a new chat with the selected user
      const response = await axios.post(`${API_BASE_URL}/api/chats`, {
        participants: [selectedUserData._id],
        isGroup: false
      });
      
      if (response && response.data) {
        // Add the new chat to the list
        setChats(prev => [response.data, ...prev]);
        
        // Select the new chat
        setSelectedChat(response.data);
        setSelectedUser(selectedUserData);
      }
    } catch (error) {
      console.error('Error creating new chat:', error);
      setApiError('Failed to create chat. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [setLoading, setApiError, setChats, setSelectedChat, setSelectedUser]);

  const handleAddUserByPhone = (foundUser) => {
    if (foundUser) {
      // Check if we already have a chat with this user
      const existingChat = chats.find(chat => {
        if (chat.isGroup) return false;
        return chat.participants.some(p => p._id === foundUser._id);
      });
      
      if (existingChat) {
        handleUserSelect(foundUser);
      } else {
        createNewChat(foundUser);
      }
    }
  };

  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };

  // Removed duplicate handleUserSelect function

  // Handle chat deletion
  const handleDeleteChat = async () => {
    if (!chatToDelete) return;
    
    try {
      setLoading(true);
      console.log('Attempting to delete chat with ID:', chatToDelete._id);
      
      // Try to refresh token before deleting
      try {
        await refreshToken();
        console.log("Token refreshed before delete operation");
      } catch (refreshError) {
        console.error("Token refresh failed:", refreshError);
        // Continue with existing token if refresh fails
      }
      
      // Call API to delete the chat
      const response = await axios.delete(`${API_BASE_URL}/api/chats/${chatToDelete._id}`);
      
      console.log('Delete response:', response.data);
      
      // Only proceed if we got a successful response
      if (response && response.status === 200) {
        // If the deleted chat is currently selected, clear the selection
        if (selectedChat && selectedChat._id === chatToDelete._id) {
          setSelectedChat(null);
          setSelectedUser(null);
          setMessages([]);
        }
        
        // Remove the chat from the list
        setChats(prevChats => prevChats.filter(chat => chat._id !== chatToDelete._id));
        
        // Clear any previous errors
        setApiError(null);
      } else {
        throw new Error('Server returned an unsuccessful status code');
      }
    } catch (error) {
      console.error('Error deleting chat:', error);
      let errorMessage = 'Failed to delete chat. Please try again later.';
      
      if (error.response) {
        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        console.error('Server error response:', error.response.data);
        console.error('Status code:', error.response.status);
        
        if (error.response.status === 401) {
          // Try to refresh token one more time with forced re-login
          try {
            await refreshToken();
            // If token refresh succeeds, try the delete operation again
            handleDeleteChat();
            return;
          } catch (refreshError) {
            // Token refresh failed, need to log in again
            errorMessage = 'Your session has expired. Please log in again.';
            logout(); // Force logout if we can't refresh the token
          }
        } else {
          errorMessage = error.response.data.msg || errorMessage;
        }
      } else if (error.request) {
        // The request was made but no response was received
        console.error('No response received:', error.request);
        errorMessage = 'No response from server. Check your connection.';
      }
      
      setApiError(errorMessage);
    } finally {
      setLoading(false);
      // Always close the dialog regardless of success/failure
      setDeleteDialogOpen(false);
      setChatToDelete(null);
    }
  };

  // Open delete confirmation dialog
  const openDeleteDialog = (event, chat) => {
    // Stop event propagation to prevent selecting the chat
    event.stopPropagation();
    
    setChatToDelete(chat);
    setDeleteDialogOpen(true);
  };

  // Close delete confirmation dialog
  const closeDeleteDialog = () => {
    setDeleteDialogOpen(false);
    setChatToDelete(null);
  };

  // Function to go back to the chat list on mobile
  const handleBackToList = () => {
    if (isMobile) {
      setMobileView('list');
    }
  };

  const handleInitiateCall = (recipientUser, callType = 'video') => {
    // Set call data
    setCurrentCall({
      recipient: recipientUser,
      callType
    });
    
    // Show call modal
    setCallModalOpen(true);
    
    // Emit call initiation event
    emitEvent('initiate_call', {
      to: recipientUser._id,
      from: user.id,
      callerName: user.name,
      callerPicture: user.profilePicture,
      callType
    });
  };

  const handleCallEnd = () => {
    // Close call modal
    setCallModalOpen(false);
    
    // Cleanup any media streams
    if (window.localStream) {
      console.log("Cleaning up media streams after call ended");
      window.localStream.getTracks().forEach(track => {
        track.stop();
      });
      window.localStream = null;
    }
    
    // Clear call data
    setCurrentCall(null);
  };

  // Handle notification settings change
  const handleNotificationSettingChange = (setting) => (event) => {
    setNotificationSettings(prev => ({
      ...prev,
      [setting]: event.target.checked
    }));
    
    // Save settings to localStorage for persistence
    localStorage.setItem('notificationSettings', JSON.stringify({
      ...notificationSettings,
      [setting]: event.target.checked
    }));
  };
  
  // Load notification settings from localStorage on component mount
  useEffect(() => {
    const savedSettings = localStorage.getItem('notificationSettings');
    if (savedSettings) {
      try {
        const parsedSettings = JSON.parse(savedSettings);
        setNotificationSettings(parsedSettings);
      } catch (error) {
        console.error('Error parsing notification settings:', error);
      }
    }
  }, []);

  // If connection is down, show connection error
  if (connectionStatus === 'disconnected') {
    return (
      <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '100vh', gap: 2 }}>
        <Typography variant="h5" color="error">Server Connection Error</Typography>
        <Typography>Cannot connect to the chat server. Please check your internet connection and try again.</Typography>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<RefreshIcon />}
          onClick={retryConnection}
        >
          Retry Connection
        </Button>
      </Box>
    );
  }

  // If connecting, show loading
  if (connectionStatus === 'connecting') {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <Typography>Connecting to server...</Typography>
      </Box>
    );
  }

  // If user is not defined or loading, show loading
  if (!user) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <Typography>Loading user data...</Typography>
      </Box>
    );
  }

  return (
      <Box sx={{ height: '100vh', overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>
        {/* App Header */}
        <AppBar 
          position={isMobile ? "fixed" : "static"} 
          color="primary"
          sx={isMobile ? { zIndex: 1200 } : {}}
        >
          <Toolbar>
            {isMobile && mobileView === 'chat' && (
              <IconButton 
                edge="start" 
                color="inherit" 
                onClick={handleBackToList}
                sx={{ mr: 2 }}
              >
                <ArrowBackIcon />
              </IconButton>
            )}
            <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
              {isMobile && mobileView === 'chat' && selectedUser 
                ? selectedUser.name 
                : 'Chat App'}
            </Typography>
            {isMobile && mobileView === 'chat' && selectedUser && (
              <Box sx={{ display: 'flex', mr: 2 }}>
                <IconButton 
                  color="inherit" 
                  onClick={() => handleInitiateCall(selectedUser, 'audio')}
                  disabled={!selectedUser.isOnline}
                >
                  <CallIcon />
                </IconButton>
                <IconButton 
                  color="inherit" 
                  onClick={() => handleInitiateCall(selectedUser, 'video')}
                  disabled={!selectedUser.isOnline}
                  aria-label="Start video call"
                >
                  <VideocamIcon />
                </IconButton>
              </Box>
            )}
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              {user && (
                <>
                  {!isMobile && (
                    <Typography variant="body2" sx={{ mr: 2 }}>
                      Hello, {user.name}
                    </Typography>
                  )}
                  <Tooltip 
                    title={
                      <Box sx={{ p: 0.5 }}>
                        <Typography variant="subtitle2">{user.name}</Typography>
                        <Typography variant="caption" sx={{ opacity: 0.8 }}>
                          {user.status || 'Available'}
                        </Typography>
                      </Box>
                    }
                  >
                    <IconButton 
                      onClick={(e) => setProfileAnchorEl(e.currentTarget)} 
                      color="inherit"
                      sx={{ 
                        p: isMobile ? 0.25 : 0.5,
                        mr: isMobile ? 0.5 : 0
                      }}
                      aria-label="Profile menu"
                    >
                      <Badge
                        overlap="circular"
                        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
                        variant="dot"
                        color={user.isOnline ? "success" : "default"}
                        sx={{
                          '& .MuiBadge-badge': {
                            width: 10,
                            height: 10,
                            borderRadius: '50%',
                            border: '2px solid',
                            borderColor: 'background.paper',
                            ...(user.isOnline && {
                              animation: `${pulseAnimation} 2s infinite`,
                            })
                          }
                        }}
                      >
                        <Avatar 
                          src={user.profilePicture ? getImageUrl(user.profilePicture) : ''}
                          alt={user.name || 'User'}
                          imgProps={{
                            onError: (e) => {
                              console.log('Profile image failed to load:', e.target.src);
                              e.target.onerror = null; // Prevent infinite loop
                              e.target.style.display = 'none'; // Hide the broken image
                            },
                            style: { objectFit: 'cover' }
                          }}
                          sx={{ 
                            width: isMobile ? 36 : 40, 
                            height: isMobile ? 36 : 40,
                            border: '2px solid',
                            borderColor: user.isOnline ? 'success.main' : 'secondary.main',
                            bgcolor: !user.profilePicture ? 
                              `rgb(${Math.floor(Math.random() * 150)}, ${Math.floor(Math.random() * 150)}, ${Math.floor(Math.random() * 150)})` : 
                              'primary.main',
                            transition: 'all 0.2s ease-in-out',
                            '&:hover': {
                              transform: isMobile ? 'none' : 'scale(1.1)',
                              boxShadow: isMobile ? 'none' : '0 0 8px rgba(255,255,255,0.5)',
                              borderColor: user.isOnline ? 'success.light' : 'secondary.light',
                            },
                            fontSize: isMobile ? '1rem' : '1.2rem',
                            fontWeight: 'bold',
                            overflow: 'hidden'
                          }}
                        >
                          {user.name?.charAt(0).toUpperCase() || 'U'}
                        </Avatar>
                      </Badge>
                    </IconButton>
                  </Tooltip>
                  {/* Profile Menu */}
                  <Menu
                    anchorEl={profileAnchorEl}
                    open={Boolean(profileAnchorEl)}
                    onClose={() => setProfileAnchorEl(null)}
                    PaperProps={{
                      sx: { 
                        mt: 1.5,
                        minWidth: 180,
                        borderRadius: 2,
                        boxShadow: 3
                      }
                    }}
                  >
                    <MenuItem onClick={() => {
                      setProfileAnchorEl(null);
                      setProfileMenuOpen(true);
                    }}>
                      <PersonIcon fontSize="small" sx={{ mr: 1.5 }} />
                      Edit Profile
                    </MenuItem>
                    
                    <MenuItem onClick={() => {
                      setProfileAnchorEl(null);
                      setNotificationSettingsOpen(true);
                    }}>
                      <NotificationsIcon fontSize="small" sx={{ mr: 1.5 }} />
                      Notification Settings
                    </MenuItem>
                    
                    <Divider />
                    <MenuItem 
                      onClick={() => {
                        logout();
                        setProfileAnchorEl(null);
                      }}
                      sx={{ py: 1, color: 'error.main' }}
                    >
                      Logout
                    </MenuItem>
                  </Menu>
                  
                  {/* Notification Settings Dialog */}
                  <Dialog
                    open={notificationSettingsOpen}
                    onClose={() => setNotificationSettingsOpen(false)}
                    maxWidth="sm"
                    fullWidth
                  >
                    <DialogTitle>Notification Settings</DialogTitle>
                    <DialogContent>
                      <FormGroup>
                        <FormControlLabel
                          control={
                            <Switch 
                              checked={notificationSettings.messageNotifications}
                              onChange={handleNotificationSettingChange('messageNotifications')}
                              color="primary"
                            />
                          }
                          label="Message Notifications"
                        />
                        <Typography variant="caption" color="text.secondary" sx={{ ml: 3, mb: 2 }}>
                          Receive notifications when new messages arrive
                        </Typography>
                        
                        <FormControlLabel
                          control={
                            <Switch 
                              checked={notificationSettings.callNotifications}
                              onChange={handleNotificationSettingChange('callNotifications')}
                              color="primary"
                            />
                          }
                          label="Call Notifications"
                        />
                        <Typography variant="caption" color="text.secondary" sx={{ ml: 3, mb: 2 }}>
                          Receive notifications for incoming calls
                        </Typography>
                        
                        <FormControlLabel
                          control={
                            <Switch 
                              checked={notificationSettings.contactStatusNotifications}
                              onChange={handleNotificationSettingChange('contactStatusNotifications')}
                              color="primary"
                            />
                          }
                          label="Contact Status Notifications"
                        />
                        <Typography variant="caption" color="text.secondary" sx={{ ml: 3, mb: 2 }}>
                          Receive notifications when contacts come online or go offline
                        </Typography>
                        
                        <FormControlLabel
                          control={
                            <Switch 
                              checked={notificationSettings.messageReadNotifications}
                              onChange={handleNotificationSettingChange('messageReadNotifications')}
                              color="primary"
                            />
                          }
                          label="Read Receipt Notifications"
                        />
                        <Typography variant="caption" color="text.secondary" sx={{ ml: 3, mb: 2 }}>
                          Receive notifications when your messages are read
                        </Typography>
                        
                        <FormControlLabel
                          control={
                            <Switch 
                              checked={notificationSettings.sound}
                              onChange={handleNotificationSettingChange('sound')}
                              color="primary"
                            />
                          }
                          label="Notification Sounds"
                        />
                        <Typography variant="caption" color="text.secondary" sx={{ ml: 3, mb: 2 }}>
                          Play sounds for notifications
                        </Typography>
                      </FormGroup>
                    </DialogContent>
                    <DialogActions>
                      <Button onClick={() => setNotificationSettingsOpen(false)}>
                        Close
                      </Button>
                    </DialogActions>
                  </Dialog>
                </>
              )}
            </Box>

            {/* Floating action button for adding users by phone on mobile */}
            {isMobile && (
              <Fab 
                color="primary" 
                aria-label="add chat"
                onClick={() => setOpenAddByPhone(true)}
                sx={{ 
                  position: 'absolute', 
                  bottom: 20, 
                  right: 20, 
                  zIndex: 1000 
                }}
              >
                <PersonAddIcon />
              </Fab>
            )}
          </Toolbar>
        </AppBar>
        
        {/* Add padding when header is fixed on mobile */}
        {isMobile && <Box sx={{ height: '64px' }} />}
        
        {/* Main Content */}
        <Grid container sx={{ flexGrow: 1, overflow: 'hidden' }}>
          {/* Left column - Chats and Users list - Hidden on mobile when viewing a chat */}
          <Grid 
            item 
            xs={12} 
            md={4} 
            sx={{ 
              height: '100%', 
              borderRight: '1px solid #e0e0e0',
              display: isMobile && mobileView === 'chat' ? 'none' : 'flex',
              flexDirection: 'column'
            }}
          >
            {/* Tabs for switching between chats and users */}
            <Tabs
              value={activeTab}
              onChange={handleTabChange}
              variant="fullWidth"
              indicatorColor="primary"
              textColor="primary"
              sx={{ borderBottom: 1, borderColor: 'divider' }}
            >
              <Tab label="Chats" icon={<ChatIcon />} iconPosition="start" />
              <Tab label="Users" icon={<PersonIcon />} iconPosition="start" />
            </Tabs>
            
            {/* Search input (optional) */}
            <Box sx={{ p: 2, borderBottom: '1px solid #e0e0e0' }}>
              <TextField
                fullWidth
                size="small"
                placeholder={activeTab === 0 ? "Search chats..." : "Search users..."}
                variant="outlined"
                sx={{ mb: 1 }}
              />
            </Box>
            
            {/* Content area - scrollable */}
            <Box sx={{ flexGrow: 1, overflow: 'auto', bgcolor: 'background.paper' }}>
              {/* Chats tab content */}
              {activeTab === 0 && (
                <List>
                  {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
                      <CircularProgress size={30} />
                    </Box>
                  ) : chats.length === 0 ? (
                    <Box sx={{ p: 3, textAlign: 'center', color: 'text.secondary' }}>
                      <Typography>No chats yet.</Typography>
                      <Typography variant="body2">Start a conversation with a user!</Typography>
                    </Box>
                  ) : (
                    chats.map(chat => {
                      // Find the other user in the chat (assuming 1-on-1 chats)
                      const chatUser = chat.user || chat.participants?.find(p => p._id !== user.id);
                      const isSelected = selectedChat && selectedChat._id === chat._id;
                      
                      return (
                        <ListItem
                          key={chat._id}
                          button
                          selected={isSelected}
                          onClick={() => handleChatSelect(chat, chatUser)}
                          sx={{
                            borderLeft: isSelected ? '4px solid' : 'none',
                            borderColor: isSelected ? 'primary.main' : 'transparent',
                            bgcolor: isSelected ? 'action.selected' : 'transparent',
                            transition: 'all 0.2s',
                            '&:hover': {
                              bgcolor: 'action.hover',
                            }
                          }}
                        >
                          <ListItemAvatar>
                            <Badge
                              overlap="circular"
                              anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
                              variant="dot"
                              color={chatUser?.isOnline ? "success" : "default"}
                            >
                              <Avatar 
                                src={chatUser?.profilePicture ? getImageUrl(chatUser.profilePicture) : ''}
                                alt={chatUser?.name || 'User'}
                              >
                                {chatUser?.name?.charAt(0) || 'U'}
                              </Avatar>
                            </Badge>
                          </ListItemAvatar>
                          <ListItemText
                            primary={
                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <Typography 
                                  sx={{ 
                                    fontWeight: chat.unreadCount > 0 ? 'bold' : 'normal',
                                    color: chat.unreadCount > 0 ? 'text.primary' : 'inherit'
                                  }}
                                  noWrap
                                >
                                  {chatUser?.name || 'Unknown User'}
                                </Typography>
                                {chat.lastMessage?.createdAt && (
                                  <Typography variant="caption" color="text.secondary">
                                    {format(chat.lastMessage.createdAt)}
                                  </Typography>
                                )}
                              </Box>
                            }
                            secondary={
                              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <Typography 
                                  variant="body2" 
                                  color="text.secondary" 
                                  sx={{ 
                                    maxWidth: '70%',
                                    whiteSpace: 'nowrap',
                                    overflow: 'hidden',
                                    textOverflow: 'ellipsis',
                                    fontWeight: chat.unreadCount > 0 ? 'medium' : 'normal'
                                  }}
                                >
                                  {getLastMessagePreview(chat)}
                                </Typography>
                                {chat.unreadCount > 0 && (
                                  <Badge 
                                    badgeContent={chat.unreadCount} 
                                    color="primary"
                                    sx={{ ml: 'auto' }}
                                  />
                                )}
                              </Box>
                            }
                          />
                          <ListItemSecondaryAction>
                            <IconButton 
                              edge="end" 
                              aria-label="delete" 
                              onClick={(e) => openDeleteDialog(e, chat)}
                              size="small"
                            >
                              <DeleteIcon fontSize="small" />
                            </IconButton>
                          </ListItemSecondaryAction>
                        </ListItem>
                      );
                    })
                  )}
                </List>
              )}
              
              {/* Users tab content */}
              {activeTab === 1 && (
                <List>
                  {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
                      <CircularProgress size={30} />
                    </Box>
                  ) : users.length === 0 ? (
                    <Box sx={{ p: 3, textAlign: 'center', color: 'text.secondary' }}>
                      <Typography>No users found.</Typography>
                      <Button 
                        variant="contained" 
                        color="primary" 
                        onClick={() => {
                          console.log("Manual fetchUsers triggered");
                          fetchUsers();
                        }}
                        sx={{ mt: 2 }}
                      >
                        Refresh Users
                      </Button>
                    </Box>
                  ) : (
                    users.filter(u => u._id !== user.id).map(u => (
                      <ListItem
                        key={u._id}
                        button
                        onClick={() => handleUserSelect(u)}
                        sx={{
                          transition: 'all 0.2s',
                          '&:hover': {
                            bgcolor: 'action.hover',
                          }
                        }}
                      >
                        <ListItemAvatar>
                          <Badge
                            overlap="circular"
                            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
                            variant="dot"
                            color={u.isOnline ? "success" : "default"}
                            sx={{
                              '& .MuiBadge-badge': {
                                ...(u.isOnline && {
                                  animation: `${pulseAnimation} 2s infinite`,
                                })
                              }
                            }}
                          >
                            <Avatar 
                              src={u.profilePicture ? getImageUrl(u.profilePicture) : ''}
                              alt={u.name || 'User'}
                            >
                              {u.name?.charAt(0) || 'U'}
                            </Avatar>
                          </Badge>
                        </ListItemAvatar>
                        <ListItemText
                          primary={u.name}
                          secondary={
                            <Typography variant="body2" color="text.secondary">
                              {u.status || (u.isOnline ? 'Online' : 'Offline')}
                            </Typography>
                          }
                        />
                      </ListItem>
                    ))
                  )}
                </List>
              )}
            </Box>
          </Grid>
          
          {/* Right column - Chat area - Full width on mobile when viewing a chat */}
          <Grid 
            item 
            xs={12} 
            md={8} 
            sx={{ 
              height: '100%',
              display: (!isMobile || mobileView === 'chat') ? 'block' : 'none',
              position: isMobile ? 'relative' : 'static'
            }}
          >
            {selectedUser ? (
              <Box sx={{ 
                height: '100%', 
                display: 'flex', 
                flexDirection: 'column',
                ...(isMobile && {
                  height: '100%',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0
                })
              }}>
                {/* Chat header - for desktop only, mobile uses AppBar above */}
                {!isMobile && (
                  <Box sx={{ p: 2, borderBottom: '1px solid #e0e0e0', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Avatar src={getImageUrl(selectedUser.profilePicture)}>
                        {selectedUser.name?.charAt(0)}
                      </Avatar>
                      <Box sx={{ ml: 2 }}>
                        <Typography variant="subtitle1">{selectedUser.name}</Typography>
                        <Typography variant="body2" color="text.secondary">
                          {selectedUser.isOnline ? 'Online' : 'Offline'}
                        </Typography>
                      </Box>
                    </Box>
                    
                    <Box>
                      <Tooltip title="Voice Call">
                        <IconButton 
                          onClick={() => handleInitiateCall(selectedUser, 'audio')}
                          disabled={!selectedUser.isOnline}
                          color="primary"
                        >
                          <CallIcon />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="Video Call">
                        <IconButton 
                          onClick={() => handleInitiateCall(selectedUser, 'video')}
                          disabled={!selectedUser.isOnline}
                          aria-label="Start video call"
                        >
                          <VideocamIcon />
                        </IconButton>
                      </Tooltip>
                    </Box>
                  </Box>
                )}
                
                {/* Messages container - Scrollable area */}
                <Box 
                  sx={{ 
                    flexGrow: 1, 
                    overflow: 'auto', 
                    p: 2,
                    display: 'flex',
                    flexDirection: 'column',
                    ...(isMobile && {
                      // Add padding to account for fixed header and input area
                      pt: 2,
                      pb: 10, // Extra padding at bottom to ensure messages aren't hidden behind input box
                      height: 'calc(100% - 60px)', // Account for bottom input area
                      marginTop: '0', // No margin needed since we handle padding
                    })
                  }}
                >
                  {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                      <CircularProgress />
                    </Box>
                  ) : messages.length === 0 ? (
                    <Box sx={{ 
                      display: 'flex', 
                      justifyContent: 'center', 
                      alignItems: 'center', 
                      height: '100%', 
                      color: 'text.secondary' 
                    }}>
                      <Typography>No messages yet. Start a conversation!</Typography>
                    </Box>
                  ) : (
                    // Display messages in chronological order (oldest first)
                    <>
                      {messages.map(message => {
                        const isFromMe = message.sender?._id === user.id || message.sender === user.id;
                        const messageKey = `msg-${message._id || message.tempId}-${isFromMe ? 'sent' : 'received'}-${message.createdAt}`;
                        
                        return (
                          <Box 
                            key={messageKey}
                            sx={{ 
                              alignSelf: isFromMe ? 'flex-end' : 'flex-start',
                              maxWidth: isMobile ? '85%' : '70%', // Wider bubbles on mobile
                              minWidth: '120px',
                              mb: isMobile ? 2 : 1.5, // More space between messages on mobile
                              display: 'flex',
                              flexDirection: 'column'
                            }}
                          >
                            {!isFromMe && (
                              <Typography 
                                variant="caption" 
                                sx={{ 
                                  ml: 1, 
                                  mb: 0.5, 
                                  fontWeight: 'medium',
                                  color: 'text.secondary'
                                }}
                              >
                                {message.sender?.name || "User"}
                              </Typography>
                            )}
                            <Paper 
                              elevation={1}
                              sx={{ 
                                p: 1.5, 
                                backgroundColor: 
                                  message.isTemp && message.status === 'failed' ? 'error.light' :
                                  message.isTemp && message.status === 'sending' ? 'grey.300' :
                                  isFromMe ? '#1976d2' : '#e0e0e0',
                                color: 
                                  message.isTemp && message.status === 'failed' ? 'white' :
                                  message.isTemp && message.status === 'sending' ? 'text.primary' :
                                  isFromMe ? 'white' : 'text.primary',
                                borderRadius: isFromMe 
                                  ? '15px 15px 0 15px' 
                                  : '15px 15px 15px 0',
                                opacity: message.isTemp ? 0.8 : 1,
                                transition: 'all 0.3s ease'
                              }}
                            >
                              <Typography variant="body1">{message.content}</Typography>
                              <Box sx={{ 
                                display: 'flex', 
                                justifyContent: 'flex-end', 
                                alignItems: 'center', 
                                mt: 0.5 
                              }}>
                                <Typography 
                                  variant="caption" 
                                  sx={{ 
                                    opacity: message.isTemp ? 0.7 : 0.8, 
                                    fontSize: '0.7rem' 
                                  }}
                                >
                                  {message.isTemp ? 'Sending...' : format(message.createdAt)}
                                </Typography>
                                {renderMessageStatus(message)}
                              </Box>
                            </Paper>
                          </Box>
                        );
                      })}
                      {/* The ref element for scrolling - place at the very bottom */}
                      <div ref={messagesEndRef} style={{ height: 1, marginTop: '8px' }} />
                    </>
                  )}
                  {/* Typing indicator */}
                  {selectedChat && typingUsers && typingUsers[selectedChat._id]?.length > 0 && 
                    typingUsers[selectedChat._id].filter(id => id !== user.id).length > 0 && (
                    <Box sx={{ p: 1, display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                      <CircularProgress size={16} sx={{ mr: 1 }} thickness={6} />
                      <Typography variant="caption">
                        {(() => {
                          const typingUserIds = typingUsers[selectedChat._id].filter(id => id !== user.id);
                          const typingUser = users.find(u => u._id === typingUserIds[0]);
                          return typingUserIds.length === 1 
                            ? `${typingUser?.name || 'Someone'} is typing...` 
                            : 'Multiple people are typing...';
                        })()}
                      </Typography>
                    </Box>
                  )}
                </Box>
                
                {/* Message input - Fixed at bottom on mobile */}
                <Box sx={{ 
                  p: isMobile ? 1.5 : 2, 
                  borderTop: '1px solid #e0e0e0',
                  ...(isMobile && {
                    position: 'fixed',
                    bottom: 0,
                    left: 0,
                    right: 0,
                    zIndex: 1000,
                    backgroundColor: 'background.paper',
                    boxShadow: '0px -2px 4px rgba(0,0,0,0.05)',
                    width: '100%',
                  paddingBottom: '1.5rem' // Simplified to fix linter error
                  })
                }}>
                    <Grid container spacing={1} alignItems="center">
                      <Grid item xs>
                        <TextField
                          fullWidth
                          placeholder="Type a message..."
                          variant="outlined"
                          size={isMobile ? "medium" : "small"}
                          value={newMessage}
                          onChange={handleTyping}
                          disabled={connectionStatus !== 'connected'}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                          e.preventDefault();
                          handleSendMessage();
                        }
                      }}
                          InputProps={{
                        style: { fontSize: '16px' }
                          }}
                        />
                      </Grid>
                      <Grid item>
                    <IconButton 
                          color="primary" 
                      onClick={() => handleSendMessage()}
                          disabled={!newMessage.trim() || connectionStatus !== 'connected' || !selectedUser}
                          aria-label="Send message"
                          sx={{
                        backgroundColor: 'primary.main',
                        color: 'white',
                        width: { xs: 48, sm: 40 },
                            height: { xs: 48, sm: 40 },
                        '&:hover': {
                          backgroundColor: 'primary.dark',
                        },
                        '&.Mui-disabled': {
                          backgroundColor: 'action.disabledBackground',
                          color: 'action.disabled',
                        }
                      }}
                        >
                          <SendIcon fontSize={isMobile ? "medium" : "small"} />
                    </IconButton>
                      </Grid>
                    </Grid>
                </Box>
              </Box>
            ) : (
              <Box sx={{ 
                height: '100%', 
                display: 'flex', 
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
                padding: 3,
                backgroundColor: '#f5f5f5',
                textAlign: 'center'
              }}>
                <ChatIcon sx={{ fontSize: 60, color: 'primary.main', mb: 2, opacity: 0.7 }} />
                <Typography variant="h5" gutterBottom>Welcome to Chat App</Typography>
                <Typography variant="body1" color="text.secondary" sx={{ maxWidth: 500, mb: 3 }}>
                  Select a chat from the sidebar or find a user to start messaging.
                </Typography>
                <Box sx={{ display: 'flex', gap: 2 }}>
                  <Button 
                    variant="contained" 
                    startIcon={<PersonIcon />}
                  onClick={() => setActiveTab(1)}
                  >
                    Browse Users
                  </Button>
                  <Button 
                    variant="outlined" 
                    startIcon={<PhoneIcon />}
                    onClick={() => setOpenAddByPhone(true)}
                  >
                    Add by Phone
                  </Button>
                </Box>
              </Box>
            )}
          </Grid>
        </Grid>

        {/* Add Chat by Phone Dialog */}
        <AddChatByPhone 
          open={openAddByPhone}
          onClose={() => setOpenAddByPhone(false)}
          onUserFound={handleAddUserByPhone}
        />

        {/* Delete Chat Confirmation Dialog */}
        <Dialog
          open={deleteDialogOpen}
          onClose={closeDeleteDialog}
          aria-labelledby="delete-dialog-title"
          aria-describedby="delete-dialog-description"
        >
          <DialogTitle id="delete-dialog-title">Remove Chat</DialogTitle>
          <DialogContent>
            <DialogContentText id="delete-dialog-description">
              Are you sure you want to remove this chat with{' '}
              {chatToDelete?.participants?.find(p => p._id !== user.id)?.name || 'this user'}?
              <br /><br />
              This will delete the conversation from your chat list, but the other user will still have access to previous messages.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={closeDeleteDialog} color="primary">
              Cancel
            </Button>
            <Button 
              onClick={handleDeleteChat} 
              color="error" 
              startIcon={<DeleteIcon />}
              disabled={loading}
            >
              {loading ? 'Removing...' : 'Remove Chat'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Profile Menu Dialog */}
        <ProfileMenu 
          open={profileMenuOpen}
          handleClose={() => setProfileMenuOpen(false)}
        />

        {/* Call Modal */}
        <CallModal
          open={callModalOpen}
          onClose={handleCallEnd}
          callData={currentCall || {}}
          isIncoming={incomingCallData !== null}
          currentUser={user}
          socket={socket}
          emitEvent={emitEvent}
        />
        
        {/* Incoming Call Alert */}
        <IncomingCallAlert
          open={incomingCallOpen}
          caller={incomingCallData?.caller}
          onAccept={callAcceptHandler}
          onReject={callRejectHandler}
          onClose={() => setIncomingCallOpen(false)}
        />
      </Box>
  );
};

export default Chat; 


